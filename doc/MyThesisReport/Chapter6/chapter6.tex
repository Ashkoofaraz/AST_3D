\chapter{Related Work}
\label{related}
In this section we give a short overview of what other RoboCup teams have published to our knowledge about their
communication system  and compare their work to ours. There are various approaches for sharing information among
processes on a robot and among processes on different robots. These approaches can be summarized into the following main ideas:
\section{Shared Memory}
The main idea here is to define a shared memory area on each node, which holds information about the current world model. Each module can write to and/or read data from this shared location. Under this scheme, different nodes use a simple UDP protocol to exchange important data. This is quite similar to our
approach, however communication is mainly point-to-point and lacks the organization and efficiency imposed by the hierarchical topic-based publish/subscribe scheme. Furthermore, depending on the implementation, problems with corrupted data could be appear, if no lock and safety mechanisms are implemented. This idea with variations has been adopted by teams as Austin Villa~\cite{Austin-Villa},BreDoBrothers~\cite{BreDoBrothers}
\subsection{Blackboard/Shared World Model}
This is a similar idea with the previous, however different components access the central storage data via well defined interfaces, providing with the mechanisms that might be absent from the approach above. Team robots share the information of their blackboard creating a world model composed of the individual robots' perceptions.  There is one variation from GTCMU~\cite{GTCMU} where validity flags are added to the objects stored in order to declare "use with caution" when the objects are not updated for a long period of time. For intra-robot or debugging purposes custom communication systems are used over UDP or TCP.  The purpose of data exchange suggests the used protocol, for example for debugging purposes TCP is used, while when in game UDP transmission is preferred. The shared model is close to Narukom's implementation of distributed blackboard, but the exchange of newly created data requires from the programmer writing code for sending and receiving those data, whereas on Narukom newly declared Messages are immediately ready for network transfer. The vast majority of robocup teams use a slight variation of this approach such as Zadeat~\cite{Zadeat}, rUNSWift~\cite{rUNSWift}.
\subsection{Message queue and Streams}
This idea is advocated recently by team B-Human~\cite{BHuman2009} and earlier by the German
Team~\cite{GT2005}. It is based on using message queues for constructing three different types of cross-platform
communication streams: (a) inter-process communication between the cognition and the motion module, (b) debug
communication between robots and remote computers for debugging purposes, and (c) information exchange between the
robots. The first type is similar to Narukom's inter-process communication. The other two types are implemented
differently in Narukom, but they serve the same purposes. Again, this idea lacks the organization and efficiency of
Narukom. It must be noted , however that a lot of effort has been put into creating a full featured Stream library to support the required functionality, which is not present in Narukom.
\subsection{Publisher/Subscribe}
This idea is based on the publish/subscribe paradigm and has been adopted only the Austrian
Kangaroos~\cite{Austrian-Kangaroos} team. The idea is to use a publish/subscribe architecture for exchanging data between the threads on the same machine by
triggering signals in all connected modules if a subscribed memory location is altered. This design allows an IRQ-like implementation of service calls at a high system level. Network communication is done via SOAP wrapped functions calls, which generally are considered heavy compared to Narukom's approach. On the other hand, in this approach there each module a more direct access to remote data by subscribing to remote memory locations.
\section{Overview}
Generally speaking, Narukom integrates features that support any communication need in the SPL; these features are not
found collectively in any other existing communication system. One may argue that Narukom's functionality could be
implemented using the infrastructure provided by the proprietary NaoQi middle-ware offered by Aldebaran Robotics with
the Nao robots. This is true, however Narukom's purpose is to provide a communication system that does not depend on
proprietary technology and can be used widely on many different robotic teams, apart from Nao robots, and other
real-time distributed systems. Narukom also represents our efforts in departing from the dependence on the NaoQi
framework towards platform-independent customizable software architecture for robotic teams. 